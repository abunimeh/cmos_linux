#! /usr/bin/env python3

# Author: Guanyu Yi @ CPU Verification Platform Group
# Email: yigy@cpu.com.cn
# Description: verification platform main entrence

##### modules
import pcom
import env_booter
import makefile_gen
import filelst_gen
import log_parser
import fpga_signals_gen
import vplan_proc
import os
import argparse
import subprocess
import shutil
import datetime as dt
import texttable
import json

##### functions
def gen_args_top():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()
    h_str = ("input log name <MUST come first>")
    parser.add_argument('-l', dest='log', help=h_str)

    h_str = ("sub cmd about running simulation")
    run_parser = subparsers.add_parser('run', help=h_str)
    h_str = ("input simulation module")
    run_parser.add_argument('-m', dest='run_module', default='', help=h_str)
    h_str = ("toggle to elaborate all case simvs")
    run_parser.add_argument('-comp', dest='run_comp', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to compile c code for module")
    run_parser.add_argument('-cc', dest='run_cc', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to list all cases in module")
    run_parser.add_argument('-list', dest='run_list', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to run all cases of module")
    run_parser.add_argument('-all', dest='run_all', default=False,
                            action='store_true', help=h_str)
    h_str = ("input simulation case")
    run_parser.add_argument('-c', dest='run_case_lst', default=[], nargs='+',
                            help=h_str)
    h_str = ("input simulation case seed")
    run_parser.add_argument('-seed', dest='run_seed', default='', help=h_str)
    h_str = ("toggle to dump simulation waveform")
    run_parser.add_argument('-wave', dest='run_wave', default=None, nargs='*',
                            choices=['mem', 'glitch'], help=h_str)
    h_str = ("toggle to kick off verdi to open simulation waveform")
    run_parser.add_argument('-verdi', dest='run_verdi', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to kick off GUI during simulation")
    run_parser.add_argument('-gui', dest='run_gui', default=False,
                            action='store_true', help=h_str)
    h_str = ("input simulation random times")
    run_parser.add_argument('-rt', dest='run_rt', default='', help=h_str)
    h_str = ("toggle to collect coverage during simulation")
    run_parser.add_argument('-cov', dest='run_cov', default=False,
                            action='store_true', help=h_str)
    h_str = ("input type to do simulation profiling")
    run_parser.add_argument('-prof', dest='run_prof', default=[], nargs='+',
                            choices=['time', 'mem'], help=h_str)
    h_str = ("toggle to dump data for FPGA")
    run_parser.add_argument('-fpga', dest='run_fpga', default=False,
                            action='store_true', help=h_str)
    h_str = ("input analysis options")
    run_parser.add_argument('-A', dest='run_ana_opts', default='', help=h_str)
    h_str = ("input elaboration options")
    run_parser.add_argument('-E', dest='run_elab_opts', default='', help=h_str)
    h_str = ("input simulation options")
    run_parser.add_argument('-S', dest='run_simu_opts', default='', help=h_str)
    h_str = ("input custom C options")
    run_parser.add_argument('-CC', dest='run_cc_opts', default='', help=h_str)
    h_str = ("toggle to compilation from fresh")
    run_parser.add_argument('-fresh', dest='run_fresh', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to perform x86 instruction generation before")
    run_parser.add_argument('-x86_ins', dest='run_x86_ins', default=False,
                            action='store_true', help=h_str)
    h_str = ("input x86 instruction generation number")
    run_parser.add_argument('-x86_ins_num', dest='run_x86_ins_num', type=int,
                            default=21, help=h_str)
    run_parser.set_defaults(func=main_run)

    h_str = ("sub cmd about kicking off regression")
    regr_parser = subparsers.add_parser('regr', help=h_str)
    h_str = ("input regression modules")
    regr_parser.add_argument('-m', dest='regr_module_lst', default=[],
                             nargs='+', help=h_str)
    h_str = ("input regression types")
    regr_parser.add_argument('-t', dest='regr_type_lst', default=[],
                             nargs='+', help=h_str)
    h_str = ("input regression random times")
    regr_parser.add_argument('-rt', dest='regr_rt', default='', help=h_str)
    h_str = ("toggle to collect coverage during regression")
    regr_parser.add_argument('-cov', dest='regr_cov', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to kick off failed mode for regression")
    regr_parser.add_argument('-fm', dest='regr_failed_mode', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to perform x86 instruction generation before")
    regr_parser.add_argument('-x86_ins', dest='regr_x86_ins', default=False,
                            action='store_true', help=h_str)
    h_str = ("input x86 instruction generation numnber")
    regr_parser.add_argument('-x86_ins_num', dest='regr_x86_ins_num', type=int,
                             default=21, help=h_str)
    h_str = ("toggle to compilation from fresh")
    regr_parser.add_argument('-fresh', dest='regr_fresh', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to dump data for FPGA")
    regr_parser.add_argument('-fpga', dest='regr_fpga', default=False,
                            action='store_true', help=h_str)
    regr_parser.set_defaults(func=main_regr)

    h_str = ("sub cmd about merging and analyzing coverage")
    cov_parser = subparsers.add_parser('cov', help=h_str)
    h_str = ("input coverage merge modules")
    cov_parser.add_argument('-m', dest='cov_module', default='', help=h_str)
    h_str = ("toggle to merge coverage together")
    cov_parser.add_argument('-merge', dest='cov_merge', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to generate coverage report")
    cov_parser.add_argument('-rpt', dest='cov_rpt', default=False,
                            action='store_true', help=h_str)
    h_str = ("toggle to kick off verdi to analyze coverage")
    cov_parser.add_argument('-verdi', dest='cov_verdi', default=False,
                            action='store_true', help=h_str)
    cov_parser.set_defaults(func=main_cov)

    h_str = ("sub cmd about processing vplan")
    vplan_parser = subparsers.add_parser('vplan', help=h_str)
    h_str = ("input vplan module")
    vplan_parser.add_argument('-m', dest='vplan_module', default='',
                              help=h_str)
    h_str = ("toggle to generating or annotating vplan according to cfg files")
    vplan_parser.add_argument('-proc', dest='vplan_proc', default=False,
                              action='store_true', help=h_str)
    h_str = ("input vplan case passing rate query dates")
    vplan_parser.add_argument('-d', dest='vplan_days', type=int, default=1,
                              help=h_str)
    vplan_parser.set_defaults(func=main_vplan)

    h_str = ("sub cmd about generating auto reg")
    reg_parser = subparsers.add_parser('reg', help=h_str)
    h_str = ("input reg module")
    reg_parser.add_argument('-m', dest='reg_module', default='',
                            help=h_str)
    h_str = ("toggle to generate auto reg files")
    reg_parser.add_argument('-gen', dest='reg_gen', default=False,
                            action='store_true', help=h_str)
    reg_parser.set_defaults(func=main_reg)

    h_str = ("sub cmd about generating natural docs")
    doc_parser = subparsers.add_parser('doc', help=h_str)
    h_str = ("input doc module")
    doc_parser.add_argument('-m', dest='doc_module', default='',
                            help=h_str)
    h_str = ("toggle to generate natural docs")
    doc_parser.add_argument('-gen', dest='doc_gen', default=False,
                            action='store_true', help=h_str)
    doc_parser.set_defaults(func=main_doc)

    h_str = ("sub cmd about cleaning output")
    clean_parser = subparsers.add_parser('clean', help=h_str)
    h_str = ("input clean module")
    clean_parser.add_argument('-m', dest='clean_module', default='',
                              help=h_str)
    h_str = ("input clean case")
    clean_parser.add_argument('-c', dest='clean_case_lst', default=[],
                              nargs='+', help=h_str)
    h_str = ("toggle to clean output coverage dir")
    clean_parser.add_argument('-cov', dest='clean_cov', default=False,
                              action='store_true', help=h_str)
    h_str = ("toggle to clean leda dir")
    clean_parser.add_argument('-leda', dest='clean_leda', default=False,
                              action='store_true', help=h_str)
    clean_parser.set_defaults(func=main_clean)

    h_str = ("sub cmd about generating environments")
    gen_parser = subparsers.add_parser('gen', help=h_str)
    h_str = ("input gen module")
    gen_parser.add_argument('-m', dest='gen_module', default='', help=h_str)
    h_str = ("input gen module dir")
    gen_parser.add_argument('-d', dest='gen_module_dir', default='',
                            help=h_str)
    gen_parser.set_defaults(func=main_gen)

    h_str = ("sub cmd about leda flow")
    leda_parser = subparsers.add_parser('leda', help=h_str)
    leda_gg_group = leda_parser.add_mutually_exclusive_group()
    h_str = ("toggle to generate leda logs")
    leda_gg_group.add_argument('-gen_log', dest='leda_gen_log', default=False,
                             action='store_true', help=h_str)
    h_str = ("input base rtl flist files")
    leda_parser.add_argument('-f', dest='leda_flist_lst', default=[],
                             nargs='+', help=h_str)
    h_str = ("input black box flist files")
    leda_parser.add_argument('-bbf', dest='leda_bb_flist_lst', default=[],
                             nargs='+', help=h_str)
    h_str = ("input base rtl top module")
    leda_parser.add_argument('-t', dest='leda_top', default='', help=h_str)
    h_str = ("toggle to kick off leda gui")
    leda_gg_group.add_argument('-gui', dest='leda_gui', default=False,
                             action='store_true', help=h_str)
    leda_parser.set_defaults(func=main_leda)

    return parser.parse_args()

def rmtree(path_lst):
    for path in path_lst:
        if os.sep+os.path.basename(path) in os.getcwd():
            raise Exception("it is in dir {0}, please cd out from {0} since "
                            "it will be cleaned".format(path))
    rm_rsp = input("{0} will be cleaned {1}--> yes or no? "
                   "".format(path_lst, os.linesep))
    if rm_rsp in ('yes', 'y'):
        for path in path_lst:
            shutil.rmtree(path, ignore_errors=True)
            LOG.info("cleaning {0} dir done".format(path))
    else:
        LOG.info("canceled")

def update_status(case_dic):
    if (case_dic['simu_status'] == 'passed' and
        case_dic['elab_status'] == 'passed' and
        case_dic['tb_ana_status'] == 'passed' and
        case_dic['dut_ana_status'] == 'passed'):
        case_dic['status'] = case_dic['simu_status']
        case_dic['estage'] = 'NA'
        case_dic['einfo'] = case_dic['simu_error']
    elif case_dic['elab_status'] == 'passed':
        case_dic['status'] = case_dic['simu_status']
        case_dic['estage'] = 'simulation'
        case_dic['einfo'] = case_dic['simu_error']
    elif case_dic['tb_ana_status'] == 'passed':
        case_dic['status'] = case_dic['elab_status']
        case_dic['estage'] = 'elaboration'
        case_dic['einfo'] = case_dic['elab_error']
    elif case_dic['dut_ana_status'] == 'passed':
        case_dic['status'] = case_dic['tb_ana_status']
        case_dic['estage'] = 'tb analysis'
        case_dic['einfo'] = case_dic['tb_ana_error']
    else:
        case_dic['status'] = case_dic['rlt_ana_status']
        case_dic['estage'] = 'dut analysis'
        case_dic['einfo'] = case_dic['dut_ana_error']
    return case_dic

def gen_ef_str(ced):
    ef_str = ''
    for ef in pcom.find_iter(ced['MODULE_CONFIG'], '*.el'):
        ef_str += '-elfile {0} '.format(ef)
    return ef_str

def main_run(args):
    if args.run_module or args.run_case_lst:
        run = Run(args.run_module,
                  args.run_case_lst,
                  args.run_all,
                  args.run_comp,
                  args.run_cc,
                  args.run_list,
                  args.run_wave,
                  args.run_verdi,
                  args.run_gui,
                  args.run_rt,
                  args.run_cov,
                  args.run_prof,
                  args.run_fpga,
                  args.run_fresh,
                  args.run_x86_ins,
                  args.run_x86_ins_num,
                  args.run_seed,
                  args.run_ana_opts,
                  args.run_elab_opts,
                  args.run_simu_opts,
                  args.run_cc_opts)
        run.simulation()
        LOG.info("running simulation of {0} from {1} module done".format(
            args.run_case_lst, args.run_module))
    else:
        raise Exception("missing main arguments")

def main_regr(args):
    if args.regr_module_lst:
        regr = Regr(args.regr_module_lst,
                    args.regr_type_lst,
                    args.regr_rt,
                    args.regr_cov,
                    args.regr_failed_mode,
                    args.regr_x86_ins,
                    args.regr_x86_ins_num,
                    args.regr_fresh,
                    args.regr_fpga)
        regr.regression()
        LOG.info("running regression of {0} from {1} module done".format(
            args.regr_type_lst, args.regr_module_lst))
    else:
        raise Exception("missing main arguments")

def main_cov(args):
    if args.cov_module and (args.cov_merge or args.cov_rpt or args.cov_verdi):
        ced, cfg_dic = env_booter.EnvBooter(LOG, args.cov_module).proj_env()
        ef_str = gen_ef_str(ced)
        cov_merge_vdb = ced['COV_MERGE_DIR']+os.sep+ced['MODULE']+'_merge.vdb'
        cd_str = 'cd {0} && '.format(os.path.dirname(cov_merge_vdb))
        cov_str = ''
        if args.cov_merge:
            vdb_lst = list(pcom.find_iter(ced['COV_CM_DIR'], '*.vdb', True))
            if not vdb_lst:
                raise Exception("no coverage data found")
            merge_lst_file = ced['COV_MERGE_DIR']+os.sep+'merge_lst'
            os.makedirs(os.path.dirname(merge_lst_file), exist_ok=True)
            with open(merge_lst_file, 'w') as mf:
                for vdb_dir in vdb_lst:
                    mf.write(vdb_dir+os.linesep)
                    if os.path.isdir(cov_merge_vdb):
                        mf.write(cov_merge_vdb)
            cov_str = ('{0} urg -full64 -f {1} -dbname {2} -noreport {3}'
                       ''.format(cd_str, merge_lst_file,
                                 os.path.basename(cov_merge_vdb), ef_str))
            subprocess.run(cov_str, shell=True, check=True)
            for cc_dir in pcom.find_iter(ced['COV_CM_DIR'], 'testdata', True):
                shutil.rmtree(cc_dir, ignore_errors=True)
        if args.cov_rpt:
            if not os.path.isdir(cov_merge_vdb):
                raise Exception("coverage merge dir {0} is NA".format(
                    cov_merge_vdb))
            cov_str = '{0} urg -full64 -dir {1} {2} -format both'.format(
                cd_str, cov_merge_vdb, ef_str)
            subprocess.run(cov_str, shell=True)
        if args.cov_verdi:
            if not os.path.isdir(cov_merge_vdb):
                raise Exception("coverage merge dir {0} is NA".format(
                    cov_merge_vdb))
            cov_str = '{0} verdi -cov -covdir {1} {2} &'.format(
                cd_str, cov_merge_vdb, ef_str)
            subprocess.run(cov_str, shell=True)
        LOG.info("running coverage of {0} module done".format(args.cov_module))
    else:
        raise Exception("missing main arguments")

def main_vplan(args):
    if args.vplan_module and args.vplan_proc:
        ced, cfg_dic = env_booter.EnvBooter(LOG, args.vplan_module).proj_env()
        vplan = vplan_proc.VPlanProc(LOG, ced, cfg_dic, args.vplan_days)
        vplan.proc_vplan()
        LOG.info("processing vplan of {0} module done".format(
            args.vplan_module))
    else:
        raise Exception("missing main arguments")

def main_reg(args):
    if args.reg_module and args.reg_gen:
        ced, cfg_dic = env_booter.EnvBooter(LOG, args.reg_module).proj_env()
        tb_top_lst = pcom.rd_cfg(cfg_dic['simv'], 'DEFAULT', 'tb_top')
        tb_top = tb_top_lst[0] if tb_top_lst else 'test_top'
        reg_str_lst = []
        for reg_file in pcom.find_iter(ced['MODULE_REG'], '*.ralf'):
            reg_str_lst.append('ralgen -full64 -t {0} -uvm -c F -a {1} '
                               ''.format(tb_top, reg_file))
        subprocess.run(' && '.join(reg_str_lst), shell=True)
    else:
        raise Exception("missing main arguments")

def main_doc(args):
    if args.doc_module and args.doc_gen:
        ced, cfg_dic = env_booter.EnvBooter(LOG, args.doc_module).proj_env()
        os.makedirs(ced['MODULE_DOC'], exist_ok=True)
        doc_str = ('NaturalDocs -i ${PROJ_MODULE} -o HTML ${MODULE_DOC} '
                   '-p ${MODULE_DOC}')
        subprocess.run(doc_str, shell=True)
    else:
        raise Exception("missing main arguments")

def main_clean(args):
    if args.clean_module or args.clean_case_lst:
        module_name = (args.clean_case_lst[0].split('__')[0] if not
                       args.clean_module else args.clean_module)
        if not module_name:
            raise Exception(
                "case {0} is not in standard format <module__case>, "
                "so module name must be specified".format(
                    args.clean_case_lst[0]))
        ced, cfg_dic = env_booter.EnvBooter(LOG, module_name).proj_env()
        if args.clean_cov:
            rmtree([ced['COV_DIR']])
        elif not args.clean_case_lst:
            rmtree([ced['MODULE_OUTPUT']])
        else:
            rmtree([ced['MODULE_OUTPUT']+os.sep+cc for cc in
                    args.clean_case_lst if cc])
    elif args.clean_leda:
        rm_rsp = input("leda dir will be cleaned, except leda.tcl{0}"
                       "--> yes or no? ".format(os.linesep))
        if rm_rsp in ('yes', 'y'):
            ced, cfg_dic = env_booter.EnvBooter(LOG).boot_env()
            for dir_name in pcom.find_iter(ced['SHARE_LEDA'], '*', True):
                shutil.rmtree(dir_name, ignore_errors=True)
            for file_name in pcom.find_iter(
                    ced['SHARE_LEDA'], 'leda*', i_str='leda.tcl'):
                os.remove(file_name)
    else:
        raise Exception("missing main arguments")

def main_gen(args):
    ced, cfg_dic = env_booter.EnvBooter(LOG).boot_env()
    if args.gen_module:
        module_dir = (args.gen_module_dir if
                      args.gen_module_dir else ced['PROJ_VERIF'])
        module_path = os.path.expandvars(module_dir+os.sep+args.gen_module)
        if os.path.isdir(module_path):
            raise Exception("module path you typed {0} has already existed"
                            "".format(module_path))
        shutil.copytree(ced['PJ_TEMPLATES']+os.sep+'module', module_path)
        LOG.info(
            "module {0} env is generated, and its path is {1}."
            "{2}{2}It is necessary to modify the following files according to "
            "pj doc (//http://172.51.13.205:8000/static/doc/_build/html/"
            "index.html) to make it work:{2}{3}{2}{4}{2}{5}{2}{6}{2}{2}"
            "It is optional to modify the following files according to "
            "pj doc to make it work:{2}{7}{2}".format(
                args.gen_module, module_path, os.linesep,
                module_path+os.sep+'config'+os.sep+'case.cfg',
                module_path+os.sep+'config'+os.sep+'simv.cfg',
                module_path+os.sep+'flist'+os.sep+'rtl.flist',
                module_path+os.sep+'flist'+os.sep+'tb.flist',
                module_path+os.sep+'flist'+os.sep+'bfm.flist'))
    else:
        raise Exception("missing main arguments")

def main_leda(args):
    ced, cfg_dic = env_booter.EnvBooter(LOG).boot_env()
    leda_dir = ced['PROJ_SHARE']+os.sep+'leda'
    if args.leda_gen_log and args.leda_flist_lst:
        for leda_flist in args.leda_flist_lst:
            if not os.path.isfile(leda_flist):
                raise Exception(
                    "base flist file {0} is NA".format(leda_flist))
        os.makedirs(leda_dir, exist_ok=True)
        df_tup = filelst_gen.FilelstGen(LOG).gen_file_lst(args.leda_flist_lst)
        dir_lst, verilog_lst, vhdl_lst = df_tup
        flist_file = leda_dir+os.sep+'leda.flist'
        wl_file = leda_dir+os.sep+'leda_on_off_warning.log'
        with open(flist_file, 'w') as lf, open(wl_file, 'w') as wf:
            for lf_line in verilog_lst+vhdl_lst:
                lf.write(lf_line+os.linesep)
                with open(lf_line, errors='replace') as vf:
                    vf_con = vf.read()
                if 'leda off' in vf_con:
                    wline = "leda off in file {0}".format(lf_line)
                    LOG.warning(wline)
                    wf.write(wline)
                if 'leda on' in vf_con:
                    wline = "leda on in file {0}".format(lf_line)
                    LOG.warning(wline)
                    wf.write(wline)
            for ld_line in dir_lst:
                lf.write(ld_line+os.linesep)
        bb_str = ''
        if args.leda_bb_flist_lst:
            bb_con = ''
            for leda_bb_flist in args.leda_bb_flist_lst:
                if not os.path.isfile(leda_bb_flist):
                    raise Exception(
                        "black box flist file {0} is NA".format(leda_bb_flist))
                with open(leda_bb_flist) as bf:
                    bb_con += bf.read()+os.linesep
            bb_flist_file = leda_dir+os.sep+'leda_bb.flist'
            with open(bb_flist_file, 'w') as lbf:
                lbf.write(bb_con)
            bb_str = '-bbox_file {0} '.format(bb_flist_file)
        leda_opts = ' '.join(pcom.rd_cfg(cfg_dic['proj'], 'leda', 'opts'))
        top_str = args.leda_top if args.leda_top else pcom.rd_cfg(
            cfg_dic['proj'], 'proj', 'rtl_top')[0]
        leda_str = 'cd {0} && leda {1} -config {2} -f {3} {4} -top {5}'.format(
            leda_dir, leda_opts, leda_dir+os.sep+'leda.tcl', flist_file,
            bb_str, top_str)
        with open(leda_dir+os.sep+'leda_cmd', 'w') as lcf:
            lcf.write(leda_str+os.linesep)
        subprocess.run(leda_str, shell=True,
                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    elif args.leda_gui:
        leda_str = 'cd {0} && leda +gui -config {1} -l {2}'.format(
            leda_dir, leda_dir+os.sep+'leda.tcl',
            leda_dir+os.sep+'leda-logs'+os.sep+'leda.log')
        subprocess.run(leda_str, shell=True)
    else:
        raise Exception("missing main arguments")

##### classes
class Run(object):
    def __init__(self, run_module,
                 run_case_lst,
                 run_all,
                 run_comp,
                 run_cc,
                 run_list,
                 run_wave,
                 run_verdi,
                 run_gui,
                 run_rt,
                 run_cov,
                 run_prof,
                 run_fpga,
                 run_fresh,
                 run_x86_ins,
                 run_x86_ins_num,
                 run_seed,
                 run_ana_opts,
                 run_elab_opts,
                 run_simu_opts,
                 run_cc_opts):
        self.run_module = run_module
        self.run_case_lst = [cc.split('.')[0] for cc in run_case_lst if cc]
        if not run_module:
            self.run_module = run_case_lst[0].split('__')[0]
        if not self.run_module:
            raise Exception(
                "case {0} is not in standard format <module__case>, so "
                "module name must be specified".format(self.run_case_lst[0]))
        self.run_all = run_all
        self.run_comp = run_comp
        self.run_cc = run_cc
        self.run_list = run_list
        self.run_wave = run_wave
        self.run_verdi = run_verdi
        self.run_fpga = run_fpga
        self.run_fresh = run_fresh
        self.run_x86_ins = run_x86_ins
        self.run_x86_ins_num = run_x86_ins_num
        self.run_seed = run_seed
        self.run_cc_opts = run_cc_opts
        self.ow_dic = {'ae': {}, 'su': {}}
        if run_seed:
            self.ow_dic['su']['seed'] = run_seed.strip()
        if run_ana_opts:
            self.ow_dic['ae']['custom_ana_opts'] = run_ana_opts.strip()
        if run_elab_opts:
            self.ow_dic['ae']['custom_elab_opts'] = run_elab_opts.strip()
        if run_simu_opts:
            self.ow_dic['su']['custom_simu_opts'] = run_simu_opts.strip()
        if run_wave != None:
            self.ow_dic['ae']['wave'] = 'on'
            self.ow_dic['su']['wave'] = 'on'
            if 'mem' in run_wave:
                self.ow_dic['su']['wave_mem'] = 'on'
            if 'glitch' in run_wave:
                self.ow_dic['su']['wave_glitch'] = 'on'
        if run_verdi:
            self.ow_dic['ae']['wave'] = 'on'
            self.ow_dic['su']['wave'] = 'on'
        if run_gui:
            self.ow_dic['ae']['gui'] = 'on'
            self.ow_dic['su']['gui'] = 'on'
        if run_rt:
            self.ow_dic['su']['random_times'] = run_rt.strip()
        if run_cov:
            self.ow_dic['ae']['cov'] = 'on'
            self.ow_dic['su']['cov'] = 'on'
        if run_prof:
            self.ow_dic['ae']['prof'] = 'on'
            if 'time' in run_prof:
                self.ow_dic['su']['prof_time'] = 'on'
            if 'mem' in run_prof:
                self.ow_dic['su']['prof_mem'] = 'on'
        if run_fpga:
            self.ow_dic['ae']['fpga'] = 'on'
        self.ced, self.cfg_dic = env_booter.EnvBooter(
            LOG, self.run_module, self.run_x86_ins,
            self.run_x86_ins_num).proj_env()
    def simulation(self):
        mk_dir, mk_file, cvs_dic, _ = makefile_gen.MakefileGen(
            LOG, self.ced, self.cfg_dic, self.ow_dic, self.run_case_lst,
            self.run_cc_opts, regr_flg=False, fresh_flg=self.run_fresh,
            x86_ins_flg=self.run_x86_ins,
            all_case_flg=self.run_all).gen_makefile()
        tar_str = ''
        if self.run_list:
            str_lst = ["all cases of module {0}".format(self.ced['MODULE'])]
            str_lst.append('*'*30)
            str_lst += list(cvs_dic)
            str_lst.append('*'*30)
            LOG.info(os.linesep.join(str_lst))
            return None
        if self.run_comp:
            tar_str += 'compile_all '
        if self.run_cc:
            tar_str += 'compile_c'
        if self.run_all:
            self.run_case_lst = list(cvs_dic)
        if self.run_case_lst:
            for run_case in self.run_case_lst:
                tar_str += 'run_simv_{0} '.format(run_case)
        if self.run_verdi:
            verdi_str = ('verdi_{0} '.format(self.run_case_lst[0]) if
                         self.run_case_lst else 'verdi_DEFAULT ')
            tar_str = tar_str+verdi_str if self.run_wave != None else verdi_str
        if not tar_str:
            tar_str = 'analysis_dut_all '
        mk_str = 'cd {0} && make -f {1} {2}'.format(mk_dir, mk_file, tar_str)
        proc = subprocess.Popen(mk_str, shell=True)
        try:
            proc.communicate()
        except KeyboardInterrupt:
            proc.communicate()
        if self.run_case_lst:
            rpt_rows = [['Case Name', 'Case Simv', 'SVN CL', 'Seed', 'Status',
                         'Error Stage', 'CPU Time']]
            if self.run_fpga:
                fsg = fpga_signals_gen.FPGASignalsGen(self.ced)
                fsg.gen_h_lst()
            for run_case in self.run_case_lst:
                for seed in cvs_dic[run_case][1:]:
                    cvs_tup = (run_case, cvs_dic[run_case][0], seed)
                    case_dic = update_status(log_parser.LogParser(
                        LOG, self.ced, self.cfg_dic, cvs_tup).parse_log())
                    if self.run_fpga:
                        fsg.gen_fpga_signals(cvs_tup)
                    rpt_rows.append([case_dic['c_name'],
                                     case_dic['v_name'],
                                     case_dic['proj_cl'],
                                     case_dic['seed'],
                                     case_dic['status'],
                                     case_dic['estage'],
                                     case_dic['simu_cpu_time']+'s'])
            table = texttable.Texttable()
            table.set_cols_width([30,7,7,7,7,7,7])
            table.add_rows(rpt_rows)
            sim_table = table.draw()
            LOG.info("simulation report table:"+os.linesep+sim_table)

class Regr(object):
    def __init__(self, regr_module_lst,
                 regr_type_lst,
                 regr_rt,
                 regr_cov,
                 regr_failed_mode,
                 regr_x86_ins,
                 regr_x86_ins_num,
                 regr_fresh,
                 regr_fpga):
        self.regr_module_lst = regr_module_lst
        self.regr_type_lst = regr_type_lst if regr_type_lst else ['sanity']
        self.regr_failed_mode = regr_failed_mode
        self.regr_x86_ins = regr_x86_ins
        self.regr_x86_ins_num = regr_x86_ins_num
        self.regr_fresh = regr_fresh
        self.regr_fpga = regr_fpga
        self.ow_dic = {'ae': {}, 'su': {}}
        if regr_rt:
            self.ow_dic['su']['random_times'] = regr_rt.strip()
        if regr_cov:
            self.ow_dic['ae']['cov'] = 'on'
            self.ow_dic['su']['cov'] = 'on'
        if regr_fpga:
            self.ow_dic['ae']['fpga'] = 'on'
        self.rpt_rows = [['Case Name', 'Case Simv', 'SVN CL', 'Seed', 'Status',
                          'Error Stage', 'CPU Time']]
        self.rpt_dic_lst = []
    def sim_and_parse(self, ced, cfg_dic, cvs_tup, mk_str, fsg):
        case, simv, seed = cvs_tup
        subprocess.run(mk_str+'run_simv_{0}__{1}'.format(case, seed),
                       shell=True, check=True, stdout=subprocess.PIPE,
                       stderr=subprocess.PIPE)
        case_dic = update_status(log_parser.LogParser(
            LOG, ced, cfg_dic, cvs_tup).parse_log())
        if self.regr_fpga:
            fsg.gen_fpga_signals(cvs_tup)
        log_str = (
            "Case Name: {1}{0}Seed: {2}{0}Status: {3}{0}Error Stage: {4}"
            "".format(os.linesep+' '*16, case_dic['c_name'], case_dic['seed'],
                      case_dic['status'], case_dic['estage']))
        if case_dic['status'] == 'passed':
            LOG.info(log_str)
        else:
            LOG.error(log_str)
        self.rpt_rows.append(
            [case_dic['c_name'], case_dic['v_name'], case_dic['proj_cl'],
             case_dic['seed'], case_dic['status'], case_dic['estage'],
             case_dic['simu_cpu_time']+'s'])
        self.rpt_dic_lst.append(
            {'case': case_dic['c_name'], 'seed': case_dic['seed'],
             'status': case_dic['status']})
    def regression(self):
        for regr_module in self.regr_module_lst:
            ced, cfg_dic = env_booter.EnvBooter(
                LOG, regr_module, self.regr_x86_ins,
                self.regr_x86_ins_num).proj_env()
            if self.regr_fpga:
                fsg = fpga_signals_gen.FPGASignalsGen(ced)
                fsg.gen_h_lst()
            else:
                fsg = None
            regr_rpt_file = ced['MODULE_OUTPUT']+os.sep+'regr_rpt'
            regr_rpt_jf = ced['MODULE_OUTPUT']+os.sep+'regr_status.json'
            if self.regr_failed_mode:
                if not os.path.isfile(regr_rpt_jf):
                    raise Exception(
                        "regression report json file {0} is NA, and it is not "
                        "enough to kick off failed mode".format(regr_rpt_jf))
                mk_dir = ced['MODULE_OUTPUT']
                mk_file = mk_dir+os.sep+'Makefile'
                if not os.path.isfile(mk_file):
                    raise Exception(
                        "case make file {0} is NA, and it is not enough to "
                        "kick off failed mode".format(mk_file))
                mk_str = 'cd {0} && make -f {1} '.format(mk_dir, mk_file)
                with open(regr_rpt_jf) as jf:
                    regr_json = json.load(jf)
                for cs_dic in regr_json:
                    if cs_dic.get('status', '') != 'passed':
                        self.sim_and_parse(ced, cfg_dic, (
                            cs_dic.get('case', ''), cs_dic.get('simv', ''),
                            cs_dic.get('seed', '')), mk_str, fsg)
            else:
                subprocess.run(
                    'cd ${PROJ_ROOT} && svn up', shell=True, check=True,
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                LOG.info("updating svn to latest version done")
                mk_dir, mk_file, _, regr_dic = makefile_gen.MakefileGen(
                    LOG, ced, cfg_dic, self.ow_dic, regr_flg=True,
                    fresh_flg=self.regr_fresh,
                    x86_ins_flg=self.regr_x86_ins).gen_makefile()
                mk_str = 'cd {0} && make -f {1} '.format(mk_dir, mk_file)
                for regr_type in self.regr_type_lst:
                    LOG.info("{0} regression is running @{1}".format(
                        regr_type, ced['TIME']))
                    regr_type = regr_type.lower()
                    for cvs_tup in regr_dic.get(regr_type, []):
                        self.sim_and_parse(ced, cfg_dic, cvs_tup, mk_str, fsg)
            table = texttable.Texttable()
            table.set_cols_width([30,7,7,7,7,7,7])
            table.add_rows(self.rpt_rows)
            regr_table = table.draw()
            LOG.info("regression report table:"+os.linesep+regr_table)
            with open(regr_rpt_file, 'w') as rf:
                rf.write(regr_table)
            with open(regr_rpt_jf, 'w')  as jf:
                json.dump(self.rpt_dic_lst, jf)
            LOG.info("regression report file {0}".format(regr_rpt_file))

##### main
def main():
    args = gen_args_top()
    global LOG
    LOG = pcom.gen_logger(file_log=args.log)
    LOG.info("commence...")
    args.func(args)
    LOG.info("complete")

if __name__ == '__main__':
    try:
        main()
    except Exception as ex:
        LOG.exception(ex)
