
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>runner(pj)使用手册 &#8212; Verification Platform 1.0 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="backend构架介绍" href="backend.html" />
    <link rel="prev" title="配置文件使用手册" href="config.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="backend.html" title="backend构架介绍"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="config.html" title="配置文件使用手册"
             accesskey="P">previous</a> |</li>
<li><a href="http://172.51.13.205:8000">HOME</a> &raquo;</li>

        <li class="nav-item nav-item-0"><a href="index.html">Verification Platform 1.0 documentation</a> &#187;</li>
 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">runner(pj)使用手册</a><ul>
<li><a class="reference internal" href="#pj">初始化pj</a></li>
<li><a class="reference internal" href="#id1">子命令参数模式</a></li>
<li><a class="reference internal" href="#id2">查看pj子命令</a></li>
<li><a class="reference internal" href="#id3">pj子命令参数详细说明</a><ul>
<li><a class="reference internal" href="#init">子命令init</a></li>
<li><a class="reference internal" href="#run">子命令run</a></li>
<li><a class="reference internal" href="#cov">子命令cov</a></li>
<li><a class="reference internal" href="#vplan">子命令vplan</a></li>
<li><a class="reference internal" href="#reg">子命令reg</a></li>
<li><a class="reference internal" href="#doc">子命令doc</a></li>
<li><a class="reference internal" href="#clean">子命令clean</a></li>
<li><a class="reference internal" href="#gen">子命令gen</a></li>
<li><a class="reference internal" href="#leda">子命令leda</a></li>
<li><a class="reference internal" href="#ac">子命令ac</a></li>
<li><a class="reference internal" href="#dc">子命令dc</a></li>
<li><a class="reference internal" href="#tm">子命令tm</a></li>
<li><a class="reference internal" href="#fm">子命令fm</a></li>
<li><a class="reference internal" href="#icc">子命令icc</a></li>
<li><a class="reference internal" href="#cdc">子命令cdc</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">平台目录结构</a><ul>
<li><a class="reference internal" href="#proj-root-share-config">PROJ_ROOT/share/config/</a></li>
<li><a class="reference internal" href="#proj-root-verification-module">PROJ_ROOT/verification/MODULE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5">开发阶段说明</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="config.html"
                        title="previous chapter">配置文件使用手册</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="backend.html"
                        title="next chapter">backend构架介绍</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/runner.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="runner-pj">
<span id="runner"></span><h1>runner(pj)使用手册<a class="headerlink" href="#runner-pj" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pj">
<h2>初始化pj<a class="headerlink" href="#pj" title="Permalink to this headline">¶</a></h2>
<p>利用module来加载pj：</p>
<p><code class="docutils literal"><span class="pre">$</span> <span class="pre">module</span> <span class="pre">load</span> <span class="pre">pj</span></code></p>
<p>您也可以添加 <code class="docutils literal"><span class="pre">module</span> <span class="pre">load</span> <span class="pre">pj</span></code> 行到~/.cshrc将pj自动加载，module的详细用法可以参考 <a class="reference external" href="http://172.51.13.70/do/view/Main/Tools_configure">Tools工具配置</a></p>
</div>
<div class="section" id="id1">
<h2>子命令参数模式<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>linux多参数tools基本都是子命令参数模式，如yum, apt-get, pip, git, svn等，这种参数模式的优点是将功能点按照子命令归类，模块化边界清晰。</p>
<p>以svn为例，我们可以通过 <code class="docutils literal"><span class="pre">svn</span> <span class="pre">-h</span></code> 来查看svn所有的子命令：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ svn -h
usage: svn &lt;subcommand&gt; [options] [args]
Subversion command-line client, version 1.6.11.
Type &#39;svn help &lt;subcommand&gt;&#39; for help on a specific subcommand.
Type &#39;svn --version&#39; to see the program version and RA modules
  or &#39;svn --version --quiet&#39; to see just the version number.

Most subcommands take file and/or directory arguments, recursing
on the directories.  If no arguments are supplied to such a
command, it recurses on the current directory (inclusive) by default.

Available subcommands:
   add
   blame (praise, annotate, ann)
   cat
   changelist (cl)
   checkout (co)
   cleanup
   commit (ci)
   copy (cp)
   delete (del, remove, rm)
   diff (di)
   export
   help (?, h)
   import
   info
   list (ls)
   lock
   log
   merge
   mergeinfo
   mkdir
   move (mv, rename, ren)
   propdel (pdel, pd)
   propedit (pedit, pe)
   propget (pget, pg)
   proplist (plist, pl)
   propset (pset, ps)
   resolve
   resolved
   revert
   status (stat, st)
   switch (sw)
   unlock
   update (up)

Subversion is a tool for version control.
For additional information, see http://subversion.tigris.org/
</pre></div>
</div>
<p>其中从add开始到update都是svn的子命令，每个子命令负责一类特征明显的操作，比如checkout负责从svn code repo中取code到本地所有相关的操作，checkout的行为根据checkout后面跟的参数的不同而不同。</p>
<p>子命令checkout的参数可以通过 <code class="docutils literal"><span class="pre">svn</span> <span class="pre">checkout</span> <span class="pre">-h</span></code> 来查看：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ svn checkout -h
checkout (co): Check out a working copy from a repository.
usage: checkout URL[@REV]... [PATH]

  If specified, REV determines in which revision the URL is first
  looked up.

  If PATH is omitted, the basename of the URL will be used as
  the destination. If multiple URLs are given each will be checked
  out into a sub-directory of PATH, with the name of the sub-directory
  being the basename of the URL.

  If --force is used, unversioned obstructing paths in the working
  copy destination do not automatically cause the check out to fail.
  If the obstructing path is the same type (file or directory) as the
  corresponding path in the repository it becomes versioned but its
  contents are left &#39;as-is&#39; in the working copy.  This means that an
  obstructing directory&#39;s unversioned children may also obstruct and
  become versioned.  For files, any content differences between the
  obstruction and the repository are treated like a local modification
  to the working copy.  All properties from the repository are applied
  to the obstructing path.

  See also &#39;svn help update&#39; for a list of possible characters
  reporting the action taken.

Valid options:
  -r [--revision] ARG      : ARG (some commands also take ARG1:ARG2 range)
                             A revision argument can be one of:
                                NUMBER       revision number
                                &#39;{&#39; DATE &#39;}&#39; revision at start of the date
                                &#39;HEAD&#39;       latest in repository
                                &#39;BASE&#39;       base rev of item&#39;s working copy
                                &#39;COMMITTED&#39;  last commit at or before BASE
                                &#39;PREV&#39;       revision just before COMMITTED
  -q [--quiet]             : print nothing, or only summary information
  -N [--non-recursive]     : obsolete; try --depth=files or --depth=immediates
  --depth ARG              : limit operation by depth ARG (&#39;empty&#39;, &#39;files&#39;,
                            &#39;immediates&#39;, or &#39;infinity&#39;)
  --force                  : force operation to run
  --ignore-externals       : ignore externals definitions

Global options:
  --username ARG           : specify a username ARG
  --password ARG           : specify a password ARG
  --no-auth-cache          : do not cache authentication tokens
  --non-interactive        : do no interactive prompting
  --trust-server-cert      : accept unknown SSL server certificates without
                             prompting (but only with &#39;--non-interactive&#39;)
  --config-dir ARG         : read user configuration files from directory ARG
  --config-option ARG      : set user configuration option in the format:
                                 FILE:SECTION:OPTION=[VALUE]
                             For example:
                                 servers:global:http-library=serf
</pre></div>
</div>
<p>例如我们想checkout svn上某个特定changelist，就可以利用-r参数 <code class="docutils literal"><span class="pre">svn</span> <span class="pre">checkout</span> <span class="pre">URL</span> <span class="pre">-r</span> <span class="pre">CL</span></code> ；不想让checkout的信息打印在stdout上就可以利用-q参数 <code class="docutils literal"><span class="pre">svn</span> <span class="pre">checkout</span> <span class="pre">URL</span> <span class="pre">-q</span></code>。</p>
<p>所以checkout子命令就只负责与checkout动作相关的所有操作，其他操作比如commit，merge会有其它子命令负责。</p>
</div>
<div class="section" id="id2">
<h2>查看pj子命令<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>pj就是如上一段所讲的子命令参数体系，查看pj的全部子命令：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">usage</span><span class="p">:</span> <span class="n">pj</span> <span class="p">[</span><span class="o">-</span><span class="n">h</span><span class="p">]</span> <span class="p">{</span><span class="n">im</span><span class="p">,</span><span class="n">init</span><span class="p">,</span><span class="n">run</span><span class="p">,</span><span class="n">cov</span><span class="p">,</span><span class="n">vplan</span><span class="p">,</span><span class="n">reg</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">clean</span><span class="p">,</span><span class="n">gen</span><span class="p">,</span><span class="n">leda</span><span class="p">,</span><span class="n">ac</span><span class="p">,</span><span class="n">dc</span><span class="p">,</span><span class="n">tm</span><span class="p">,</span><span class="n">fm</span><span class="p">,</span><span class="n">icc</span><span class="p">,</span><span class="n">cdc</span><span class="p">}</span> <span class="o">...</span>

<span class="n">positional</span> <span class="n">arguments</span><span class="p">:</span>
  <span class="p">{</span><span class="n">im</span><span class="p">,</span><span class="n">init</span><span class="p">,</span><span class="n">run</span><span class="p">,</span><span class="n">cov</span><span class="p">,</span><span class="n">vplan</span><span class="p">,</span><span class="n">reg</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">clean</span><span class="p">,</span><span class="n">gen</span><span class="p">,</span><span class="n">leda</span><span class="p">,</span><span class="n">ac</span><span class="p">,</span><span class="n">dc</span><span class="p">,</span><span class="n">tm</span><span class="p">,</span><span class="n">fm</span><span class="p">,</span><span class="n">icc</span><span class="p">,</span><span class="n">cdc</span><span class="p">}</span>
    <span class="n">im</span>                  <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">running</span> <span class="n">pj</span> <span class="n">instance</span> <span class="n">messager</span>
    <span class="n">init</span>                <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">generating</span> <span class="n">initial</span> <span class="n">svn</span> <span class="n">directories</span>
    <span class="n">run</span>                 <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">running</span> <span class="n">simulation</span> <span class="ow">and</span> <span class="n">regression</span>
    <span class="n">cov</span>                 <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">merging</span> <span class="ow">and</span> <span class="n">analyzing</span> <span class="n">coverage</span>
    <span class="n">vplan</span>               <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">processing</span> <span class="n">vplan</span>
    <span class="n">reg</span>                 <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">generating</span> <span class="n">auto</span> <span class="n">reg</span>
    <span class="n">doc</span>                 <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">generating</span> <span class="n">natural</span> <span class="n">docs</span>
    <span class="n">clean</span>               <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">cleaning</span> <span class="n">output</span>
    <span class="n">gen</span>                 <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">generating</span> <span class="n">environments</span>
    <span class="n">leda</span>                <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">leda</span> <span class="n">flow</span>
    <span class="n">ac</span>                  <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">auto</span> <span class="n">connect</span> <span class="n">flow</span>
    <span class="n">dc</span>                  <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">run</span> <span class="n">dc</span>
    <span class="n">tm</span>                  <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">parsing</span> <span class="n">the</span> <span class="n">timing</span> <span class="n">report</span>
    <span class="n">fm</span>                  <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">run</span> <span class="n">formality</span>
    <span class="n">icc</span>                 <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">run</span> <span class="n">icc</span>
    <span class="n">cdc</span>                 <span class="n">sub</span> <span class="n">cmd</span> <span class="n">about</span> <span class="n">run</span> <span class="n">cdc</span>

<span class="n">optional</span> <span class="n">arguments</span><span class="p">:</span>
  <span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="o">--</span><span class="n">help</span>            <span class="n">show</span> <span class="n">this</span> <span class="n">help</span> <span class="n">message</span> <span class="ow">and</span> <span class="n">exit</span>
</pre></div>
</div>
<p>目前pj的全部子命令有：</p>
<ul class="simple">
<li>im：负责启动pj内部即时通信工具</li>
<li>init：负责项目初始化相关</li>
<li>run：负责simulation和regression相关，包括verdi</li>
<li>cov：负责coverage收集与生成报告</li>
<li>vplan：负责vplan生成与更新</li>
<li>reg：负责autoreg</li>
<li>doc：负责NaturalDocs生成</li>
<li>clean：负责clean output以及可选目录的中间文件</li>
<li>gen：负责模块级验证目录初始模板目录结构以及uvm验证环境生成</li>
<li>leda：负责leda flow</li>
<li>ac：负责自动连线</li>
<li>dc：负责dc flow</li>
<li>tm：负责独立生成dc timing报告</li>
<li>fm：负责formality flow</li>
<li>icc：负责icc flow</li>
<li>cdc: 负责cdc flow</li>
</ul>
</div>
<div class="section" id="id3">
<h2>pj子命令参数详细说明<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="init">
<h3>子命令init<a class="headerlink" href="#init" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>查看子命令init的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">init</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>列出全部可以初始化的项目：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">init</span> <span class="pre">-list</span></code></li>
</ul>
</li>
<li>在当前目录下check out出指定项目全部允许check out的目录：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">init</span> <span class="pre">-proj</span> <span class="pre">PROJ</span></code></li>
<li>有svn权限管控的项目会通过检索platform server上的可check out的dir的信息进行check out动作</li>
</ul>
</li>
<li>在当前目录下check out出指定项目下指定的子目录：<ul>
<li><code class="docutils literal"><span class="pre">$pj</span> <span class="pre">init</span> <span class="pre">-proj</span> <span class="pre">PROJ</span> <span class="pre">-dir</span> <span class="pre">DIR1</span> <span class="pre">DIR2</span></code></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="run">
<h3>子命令run<a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>查看子命令run的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>列出一个module下全部case以及全部simv：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-list</span></code></li>
<li>pj允许在proj trunk的任意dir下面跑，所以需要得到module name信息</li>
</ul>
</li>
<li>跑module下面的所有case：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-all</span></code></li>
</ul>
</li>
<li>跑一个case：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-c</span> <span class="pre">CASE</span></code></li>
</ul>
</li>
<li>跑一个case（支持case命名的隐式规则）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE(MODULE__***)</span></code></li>
<li>如果一个case name的第一个双下划线 <code class="docutils literal"><span class="pre">__</span></code> 前面是module name，就无需通过 <code class="docutils literal"><span class="pre">-m</span></code> 指定module name</li>
</ul>
</li>
<li>跑多个case：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE1</span> <span class="pre">CASE2</span> <span class="pre">...</span></code></li>
</ul>
</li>
<li>只做仿真相关c code compilation，不做rtl compilation：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-clib</span></code></li>
</ul>
</li>
<li>只做src c code独立运行，不做仿真相关c code compilation与rtl compilation：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-csrc</span></code></li>
</ul>
</li>
<li>只compilation(analysis+elaboration)，不simulation：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-comp</span></code></li>
</ul>
</li>
<li>只针对DUT进行compilation(analysis+elaboration)，不simulation：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-check_rtl</span></code></li>
</ul>
</li>
<li>指定simv（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-simv</span> <span class="pre">SIMV</span></code></li>
</ul>
</li>
<li>指定seed（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-seed</span> <span class="pre">SEED</span></code></li>
</ul>
</li>
<li>random seed（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-seed</span> <span class="pre">random</span></code></li>
</ul>
</li>
<li>dump波形（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-wave</span></code></li>
</ul>
</li>
<li>dump mem（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-wave</span> <span class="pre">mem</span></code></li>
</ul>
</li>
<li>波形显示glitch（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-wave</span> <span class="pre">glitch</span></code></li>
</ul>
</li>
<li>打开verdi自动load波形：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-verdi</span></code></li>
</ul>
</li>
<li>dump波形之后打开verdi自动load波形：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-wave</span> <span class="pre">-verdi</span></code></li>
</ul>
</li>
<li>没有tb，供desinger用verdi查看rtl：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-verdi</span></code></li>
</ul>
</li>
<li>用verdi设置断点，单步调试：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-gui</span></code></li>
</ul>
</li>
<li>指定随机次数（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-rt</span> <span class="pre">TIMES</span></code></li>
</ul>
</li>
<li>带coverage的simulation（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-cov</span></code></li>
<li>会默认load vdb constraint file PROJ_MODULE/config/cov.filter</li>
</ul>
</li>
<li>带upf功耗的simulation（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-upf</span></code></li>
<li>默认load PROJ_MODULE/upf/MODULE.upf文件</li>
<li>确保power_top被正确设置</li>
</ul>
</li>
<li>带效率分析报告的simulation（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-prof</span> <span class="pre">time</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-prof</span> <span class="pre">mem</span></code></li>
</ul>
</li>
<li>自定义tools options（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-DA</span> <span class="pre">ANA_OPTS</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-TA</span> <span class="pre">ANA_OPTS</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-E</span> <span class="pre">ELAB_OPTS</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-S</span> <span class="pre">SIMU_OPTS</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-CLIBC</span> <span class="pre">CLIBC_OPTS</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-CSRCC</span> <span class="pre">CSRCC_OPTS</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-CSRCR</span> <span class="pre">CSRCR_OPTS</span></code></li>
<li>分别在dut analysis, tb analysis, elaboration, simulation, 仿真c compilation, 独立c compilation, 独立c runtime这几个阶段添加用户自己需要的tools的options</li>
</ul>
</li>
<li>触发回归模式（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-t</span> <span class="pre">REGR_TYPES</span> <span class="pre">-m</span> <span class="pre">MODULE</span></code></li>
<li><code class="docutils literal"><span class="pre">-c</span></code> 参数与 <code class="docutils literal"><span class="pre">-t</span></code> 参数分别会触发仿真模式与回归模式</li>
<li>回归模式下，终端不会显示详细具体case的信息，同时会根据case.cfg里的regression_type选项来运行相应的全部case</li>
<li>所接参数与仿真模式相同</li>
</ul>
</li>
<li>从头执行compilation与simulation的动作：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-fresh</span></code></li>
<li>忽略之前compilation的结果，从头执行compilation阶段</li>
</ul>
</li>
<li>生成fpga组相应的signal data数据（*）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-fpga</span></code></li>
</ul>
</li>
<li>指定regression类型kick off regression：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-t</span> <span class="pre">REGR_TYPE1</span> <span class="pre">REGR_TYPE2</span></code></li>
<li>regression模式下verbose信息不会打印在stdout上</li>
</ul>
</li>
<li>不执行上一次simulation passed cases：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE1</span> <span class="pre">CASE2</span> <span class="pre">-fm</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-t</span> <span class="pre">REGR_TYPE1</span> <span class="pre">REGR_TYPE2</span> <span class="pre">-fm</span></code></li>
</ul>
</li>
<li>打开x86指令自动生成开关，配置相关参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-x86_ins</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-x86_ins_num</span> <span class="pre">48</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span> <span class="pre">-x86_ins_groups</span> <span class="pre">ins_32_smoke_d0</span></code></li>
</ul>
</li>
</ul>
<p>（*）simv.cfg与case.cfg中如果配置了同样的功能，cmd中相同功能的参数可以去掉，都存在的情况下cmd args的优先级高</p>
<p>根据*标注的特点，我们可以将绝大部分的cmd args放到cfg里面来配置，cmd会被简化成统一的样式 <code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">run</span> <span class="pre">-c</span> <span class="pre">CASE</span></code> 根据平台的这个特性，这里会有两种主要的工作方式：</p>
<ul class="simple">
<li>cfg based<ul>
<li>平台的新特性</li>
<li>cmd简单</li>
<li>可以同时kick off不同options的case</li>
<li>每个特殊case的配置不需要特别记录</li>
<li>可以对所有case全局控制analysis, elaboration, simulation各个阶段</li>
</ul>
</li>
<li>cmd args based<ul>
<li>之前验证环境使用的比较传统的工作方式</li>
<li>每个case都用cmd args的方式来控制</li>
<li>学习成本低</li>
</ul>
</li>
</ul>
<p>大家可以根据自己的喜好来选择不同的工作方式，也可以各取所需，结合它们的特点混合使用</p>
<p>默认regression结束会在stdout上显示regression report table，并在output下生成rpt文件。完整的包括所有人，所有历史的report可以访问 <a class="reference external" href="http://172.51.13.205:8000/regr">http://172.51.13.205:8000/regr</a> ，关于该report平台、platform server以及平台数据库请参考 <a class="reference internal" href="backend.html#backend"><span class="std std-ref">backend构架介绍</span></a></p>
</div>
<div class="section" id="cov">
<h3>子命令cov<a class="headerlink" href="#cov" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>查看子命令cov的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">cov</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>merge一个模块的coverage：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">cov</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-merge</span></code></li>
</ul>
</li>
<li>生成coverage report：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">cov</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-rpt</span></code></li>
<li>会默认load vdb waiver PROJ_MODULE/config/*.el</li>
</ul>
</li>
<li>利用verdi打开一个模块merge好的coverage：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">cov</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-verdi</span></code></li>
<li>会默认load vdb waiver PROJ_MODULE/config/*.el</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="vplan">
<h3>子命令vplan<a class="headerlink" href="#vplan" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>查看子命令vplan的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">vplan</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>自动生成或反标模块vplan目录下的vplan：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">vplan</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-proc</span></code></li>
<li>当模块vplan目录下没有vplan时，proc起到生成的作用</li>
<li>当模块vplan目录下有vplan是，proc起到反标的作用</li>
</ul>
</li>
<li>指定case sheet的case抽取天数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">vplan</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-proc</span> <span class="pre">-d</span> <span class="pre">5</span></code></li>
<li>默认抽取jenkins帐号kick off regression 1天的结果</li>
<li>case sheet的CL Ver会指定版本号范围</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="reg">
<h3>子命令reg<a class="headerlink" href="#reg" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>查看子命令reg的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">reg</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>自动根据json的reg配置文件生成全部模块的reg rtl文件、验证用的ralf文件以及excel文档<ul>
<li><code class="docutils literal"><span class="pre">$pj</span> <span class="pre">reg</span> <span class="pre">-gen</span></code></li>
<li>reg json配置文件位于PROJ_SHARE/config/pj_reg下，以&lt;MODULE&gt;_YJD.json样式命名</li>
<li>生成的reg rtl文件位于PROJ_RTL/GX/YJD目录下</li>
<li>生成的验证用的ralf文件集成全部的reg，PROJ_VERIF/vip/cru_agent_ral/reg.ralf</li>
<li>生成的excel reg文档位于PROJ_DOC/asic/GX/YJD目录下</li>
</ul>
</li>
<li>指定模块生成相应模块的reg rtl文件、验证用的ralf文件以及excel文档<ul>
<li><code class="docutils literal"><span class="pre">$pj</span> <span class="pre">reg</span> <span class="pre">-gen</span> <span class="pre">-m</span> <span class="pre">MODULE</span></code></li>
<li>生成文件的路径与不带 <code class="docutils literal"><span class="pre">-m</span></code> 参数的相同</li>
<li>生成的验证用的ralf文件命不变，但是只有相应模块的reg信息</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="doc">
<h3>子命令doc<a class="headerlink" href="#doc" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>查看子命令doc的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">doc</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>利用NaturalDocs生成inline docs：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">doc</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-gen</span></code></li>
</ul>
</li>
<li>指定路径生成inline docs：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">doc</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-gen</span> <span class="pre">-p</span> <span class="pre">DOC_PATH</span></code></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="clean">
<h3>子命令clean<a class="headerlink" href="#clean" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>查看子命令clean的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">clean</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>clean一个module的output下特定case：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">clean</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-c</span> <span class="pre">CASE1</span> <span class="pre">CASE2</span></code></li>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">clean</span> <span class="pre">-c</span> <span class="pre">CASE</span></code> （case命名满足隐式规则情况下）</li>
<li>包括这个case的所有seed目录</li>
</ul>
</li>
<li>clean一个module的output下全部case：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">clean</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-case</span></code></li>
<li>包括多个case的所有seed目录</li>
</ul>
</li>
<li>clean一个module的coverage：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">clean</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-cov</span></code></li>
<li>包括merge的结果以及coverage reports</li>
</ul>
</li>
<li>clean一个module的output：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">clean</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-output</span></code></li>
<li>包括analysis、elaboration、simulation阶段的所有生成的文件以及所有case，请谨慎操作</li>
</ul>
</li>
<li>clean一个module的tb，并彻底revert到当前版本（主要用于清理x86指令集生成大量tests以及seqs）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">clean</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-tb</span></code></li>
</ul>
</li>
<li>clean一个module的config，并彻底revert到当前版本（主要用于清理x86指令集生成大量cfgs）：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">clean</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-config</span></code></li>
</ul>
</li>
<li>clean一个module的output, tb, config，并彻底revert相关目录到当前版本：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">clean</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-output</span> <span class="pre">-tb</span> <span class="pre">-config</span></code></li>
</ul>
</li>
</ul>
<p>pj将全部中间文件按类放置于PROJ_MODULE/output下，在了解这些分类目录的前提下，用rm也可以很方便的clean，目录结构功能细节请参考 <a class="reference internal" href="#id4">平台目录结构</a></p>
</div>
<div class="section" id="gen">
<h3>子命令gen<a class="headerlink" href="#gen" title="Permalink to this headline">¶</a></h3>
<p>gen实现用户与平台的交互，gen是方便用户生成相应的验证目录结构，运行pj的必须文件以及uvm验证环境的子命令：</p>
<ul class="simple">
<li>查看子命令gen的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">gen</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>生成模块的验证目录结构：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">gen</span> <span class="pre">-m</span> <span class="pre">MODULE</span></code></li>
<li>在verification/MODULE下面生成模块目录结构</li>
</ul>
</li>
<li>指定相应的目录生成模块的验证目录结构：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">gen</span> <span class="pre">-m</span> <span class="pre">MODULE</span> <span class="pre">-d</span> <span class="pre">MODULE_DIR</span></code></li>
<li>在MODULE_DIR/MODULE下面生成模块目录结构</li>
</ul>
</li>
</ul>
<p>配置文件proj.cfg中与gen命令相关的section有gen_agt和gen_with</p>
</div>
<div class="section" id="leda">
<h3>子命令leda<a class="headerlink" href="#leda" title="Permalink to this headline">¶</a></h3>
<p>leda是方便用户对相应的RTL进行是否符合特性规则的检查所用的工具：</p>
<ul class="simple">
<li>查看子命令leda的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">leda</span> <span class="pre">-h</span></code></li>
</ul>
</li>
</ul>
<p>src目录：</p>
<ul class="simple">
<li>src目录里面存放了一整套完整的配置可以用来跑某个模块的leda flow</li>
<li>-s参数可以用来指定特定的src目录，例如跑zszx的leda flow可以建一个zszx_src的目录，然后通过-s PATH/zszx_src指定；跑fdzx的leda flow可以建一个fdzx_src的目录，然后通过-s PATH/fdzx_src指定，PATH可以是相对路径或绝对路径</li>
<li>-s参数存在的目的是方便用户同时跑不同模块的leda flow，默认情况下src目录就是$PROJ_ROOT/flow/leda/src</li>
<li>src目录下面有bbox_file文件、leda.cfg文件、leda_rule目录、leda_waiver目录</li>
<li>bbox_file里面填写模块名，多个模块名写在多行，用来过滤leda对于这些模块的检查</li>
<li>leda_rule目录下可以放多个.tcl文件，用来保存相应的rule设置</li>
<li>leda_waiver目录下可以放多个.tcl文件，用来保存相应的waiver设置</li>
<li>pj会将这两个目录下全部.tcl文件合并生成运行目录下的leda.tcl并在运行时加载，顺序是先加载leda_rule中的后夹杂leda_waiver中的</li>
</ul>
<p>常用的添加到waiver中的tcl命令：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">rule_deselect</span> <span class="pre">-rule</span> <span class="pre">X_4015</span></code> waive掉某一种rule</li>
<li><code class="docutils literal"><span class="pre">rule_deselect</span> <span class="pre">-rule</span> <span class="pre">X_4015</span> <span class="pre">-file</span> <span class="pre">../../../../rtl/LP/addpp32.v</span></code> waive掉属于某一种rule中的某个文件</li>
<li><code class="docutils literal"><span class="pre">rule_deselect</span> <span class="pre">-rule</span> <span class="pre">X_4015</span> <span class="pre">-file</span> <span class="pre">../../../../rtl/LP/addpp32.v</span> <span class="pre">-section</span> <span class="pre">{37</span> <span class="pre">37}</span></code> waive掉属于某一种rule中的某个文件的某开始行到某结束行</li>
</ul>
<p>配置leda.cfg：</p>
<ul class="simple">
<li>打开$PROJ_ROOT/flow/leda/src/leda.cfg文件完成配置</li>
<li>配置格式与case.cfg格式相同，详见 <a class="reference internal" href="config.html#config"><span class="std std-ref">配置文件使用手册</span></a></li>
<li>leda可变配置不多，默认不变也可以正常运行</li>
<li>option error_string<ul>
<li>可以调整检测leda报错的关键字符串</li>
<li>默认是[ERROR], [FAILURE]</li>
</ul>
</li>
</ul>
<p>使用pj跑leda flow：</p>
<ul>
<li><p class="first">对相应RTL进行leda check并生成log：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">leda</span> <span class="pre">-gen_log</span> <span class="pre">-f</span> <span class="pre">FLIELIST</span> <span class="pre">-t</span> <span class="pre">LEDA_TOP</span></code></li>
<li>需要提供RTL的filelist以及top模块名</li>
<li>每次gen_log的output在$PROJ_ROOT/flow/leda/LEDA_TIMESTAMP目录下</li>
</ul>
</li>
<li><p class="first">指定特定的src目录，根据目录下的cfg, rule, waiver对相应RTL进行leda check并生成log：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">leda</span> <span class="pre">-gen_log</span> <span class="pre">-f</span> <span class="pre">FLIELIST</span> <span class="pre">-t</span> <span class="pre">LEDA_TOP</span> <span class="pre">-s</span> <span class="pre">SRC</span></code></li>
<li>不指定-s的情况下默认使用$PROJ_ROOT/flow/leda/src目录的配置</li>
</ul>
</li>
<li><p class="first">leda check过程中提供black box过滤功能：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">leda</span> <span class="pre">-gen_log</span> <span class="pre">-f</span> <span class="pre">FLIELIST</span> <span class="pre">-t</span> <span class="pre">LEDA_TOP</span></code></li>
<li>参考上面讲述src目录的bbox_file部分</li>
</ul>
</li>
<li><p class="first">打开leda GUI查看、审查与修订leda log中相应的问题：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">leda</span> <span class="pre">-gui</span> <span class="pre">-d</span> <span class="pre">LEDA_TIMESTAMP</span></code></li>
<li>打开GUI之后可以利用disable instance of rule来进行相应的review</li>
<li>批处理可以将rule_deselect的tcl命令添加到leda_waiver下的文件里</li>
</ul>
<div class="figure">
<img alt="_images/leda_gui.png" src="_images/leda_gui.png" />
</div>
</li>
</ul>
</div>
<div class="section" id="ac">
<h3>子命令ac<a class="headerlink" href="#ac" title="Permalink to this headline">¶</a></h3>
<p>ac是方便用户完成相应顶层例化自动连线的工具，主要利用emacs的verilog mode auto template：</p>
<ul class="simple">
<li>查看子命令ac的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">ac</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>指定目录对目录以及子目录下面全部的*.ac.v自动连线生成*.v：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">ac</span> <span class="pre">-d</span> <span class="pre">DIR</span></code></li>
<li>原始文件*.ac.v每次生成都会自动覆盖掉之前的*.v</li>
</ul>
</li>
</ul>
<p>以下为一段*.ac.v的语法示例：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">top</span> <span class="p">(</span><span class="o">/*</span><span class="n">AUTOARG</span><span class="o">*/</span><span class="p">);</span>
   <span class="nb">input</span>  <span class="n">top__sub_a__s1</span><span class="p">;</span>
   <span class="nb">input</span> <span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">top__sub_b__s2</span><span class="p">;</span>
   <span class="nb">input</span> <span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">top__sub_a__asdfghjk</span><span class="p">;</span>
   <span class="n">output</span> <span class="n">sub_b__top__s1</span><span class="p">;</span>

   <span class="o">/*</span><span class="n">AUTOREG</span><span class="o">*/</span>
   <span class="o">/*</span><span class="n">AUTOWIRE</span><span class="o">*/</span>

   <span class="n">sub_a</span> <span class="c1">#(/*AUTOINSTPARAM*/) sa1(// Custom Connections</span>
                                  <span class="o">.</span><span class="n">top__sub_a__ss1</span> <span class="p">(</span><span class="n">top__sub_a__asdfghjk</span><span class="p">),</span>
                                  <span class="o">/*</span><span class="n">AUTOINST</span><span class="o">*/</span><span class="p">);</span>
   <span class="n">sub_b</span> <span class="c1">#(/*AUTOINSTPARAM*/) sb1 (// Custom Connections</span>
                                   <span class="o">/*</span><span class="n">AUTOINST</span><span class="o">*/</span><span class="p">);</span>
<span class="n">endmodule</span>
<span class="o">//</span> <span class="n">Local</span> <span class="n">Variables</span><span class="p">:</span>
<span class="o">//</span> <span class="n">verilog</span><span class="o">-</span><span class="n">library</span><span class="o">-</span><span class="n">directories</span><span class="p">:(</span><span class="s2">&quot;.&quot;</span> <span class="s2">&quot;DIR_SUB_A&quot;</span> <span class="s2">&quot;DIR_SUB_B&quot;</span><span class="p">)</span>
<span class="o">//</span> <span class="n">End</span><span class="p">:</span>
</pre></div>
</div>
<ul class="simple">
<li>与正常verilog相同</li>
<li>端口命名规则为SRCMODULE__TARMODULE__SIGNAL(最初始端模块名__最终端模块名__信号名)</li>
<li>ac工具会跟据/*AUTO*/类注释标志进行自动替换</li>
<li>文件结尾的注释不可少，在verilog-library-directories中要填该top需要例化连线的子模块目录，支持相对路径，否则ac工具无法获悉子模块的端口名</li>
<li>当需要特殊连接的时候，将输入端口做特殊连接，输出端口做自动连接，因为自动生成wire是检测输出端口时才生效的</li>
</ul>
<p>当自动连线需要一个模块多例化的时候可以参考以下例子：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">top</span> <span class="p">(</span><span class="o">/*</span><span class="n">AUTOARG</span><span class="o">*/</span><span class="p">);</span>

   <span class="o">/*</span><span class="n">AUTOREG</span><span class="o">*/</span>
   <span class="o">/*</span><span class="n">AUTOWIRE</span><span class="o">*/</span>

   <span class="o">/*</span> <span class="n">sj</span> <span class="n">AUTO_TEMPLATE</span> <span class="p">(</span>
    <span class="o">.</span><span class="n">sj__zzdl__</span>\<span class="p">(</span><span class="o">.*</span>\<span class="p">)</span> <span class="p">(</span><span class="n">sj</span><span class="nd">@__zzdl__</span>\<span class="mi">1</span><span class="p">),</span>
    <span class="p">);</span><span class="o">*/</span>

   <span class="n">sj</span> <span class="c1">#(/*AUTOINSTPARAM*/) sj0 (/*AUTOINST*/);</span>
   <span class="n">sj</span> <span class="c1">#(/*AUTOINSTPARAM*/)sj2 (/*AUTOINST*/);</span>
   <span class="n">zxdl</span> <span class="c1">#(/*AUTOINSTPARAM*/) u_zxdl(/*AUTOINST*/);</span>

<span class="n">endmodule</span> <span class="o">//</span> <span class="n">top</span>
<span class="o">//</span> <span class="n">Local</span> <span class="n">Variables</span><span class="p">:</span>
<span class="o">//</span> <span class="n">verilog</span><span class="o">-</span><span class="n">library</span><span class="o">-</span><span class="n">directories</span><span class="p">:(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="o">//</span> <span class="n">End</span><span class="p">:</span>
</pre></div>
</div>
<ul class="simple">
<li>模块sj例化两份，均连接到zxdl模块</li>
<li>由于zxdl模块需要连接相同的模块的多份例化，相应多例化连接的端口信号命名需要将sj这个模块名变成sj0这类例化名</li>
<li>利用AUTO_TEMPLATE强大的正则匹配特性完成sj端的连接</li>
<li>在AUTO_TEMPLATE中，&#64;代表例化名字中的后缀数字，\(与\)之间括起来的部分是正则表达式匹配，\1表示匹配到的第1个group</li>
</ul>
</div>
<div class="section" id="dc">
<h3>子命令dc<a class="headerlink" href="#dc" title="Permalink to this headline">¶</a></h3>
<p>dc是方便用户完成相应RTL综合的基础自动化流程：</p>
<ul class="simple">
<li>查看子命令dc的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-h</span></code></li>
</ul>
</li>
</ul>
<p>src目录：</p>
<ul class="simple">
<li>src目录里面存放了一整套完整的配置可以用来跑某个模块的dc flow</li>
<li>-s参数可以用来指定特定的src目录，例如跑zszx的dc flow可以建一个zszx_src的目录，然后通过-s PATH/zszx_src指定；跑fdzx的dc flow可以建一个fdzx_src的目录，然后通过-s PATH/fdzx_src指定，PATH可以是相对路径或绝对路径</li>
<li>-s参数存在的目的是方便用户同时跑不同模块的dc flow，默认情况下src目录就是$PROJ_ROOT/flow/dc/src</li>
<li>src目录下面有dc.cfg文件、dc_template目录、fm.cfg文件、fm_template目录</li>
<li>pj会根据dc.cfg文件以及dc_template目录生成运行dc flow的tcl，根据fm.cfg文件以及fm_template目录生成运行附属fm flow的tcl</li>
</ul>
<p>配置dc.cfg：</p>
<ul class="simple">
<li>打开$PROJ_ROOT/flow/dc/src/dc.cfg与$PROJ_ROOT/flow/dc/src/fm.cfg文件完成配置</li>
<li>配置格式与case.cfg格式相同，详见 <a class="reference internal" href="config.html#config"><span class="std std-ref">配置文件使用手册</span></a></li>
<li>dc的配置复杂，需要完成正确的配置才可以正确跑通，<strong>cfg文件中的DESIGN_NAME和DESIGN_LIST必须指定</strong></li>
<li>fm.cfg的配置是为了方便完成dc flow后面的自动化formality flow</li>
<li>具体dc.cfg与fm.cfg的每一项配置的目的可以咨询后端组 <strong>qianxf&#64;cpu.com.cn</strong></li>
</ul>
<p>使用pj跑dc flow：</p>
<ul class="simple">
<li>生成tcl文件，对相应RTL进行dc综合：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-gen_tcl</span> <span class="pre">-run</span></code></li>
<li>dc综合出来的output在$PROJ_ROOT/flow/dc/DC_TIMESTAMP下面</li>
</ul>
</li>
<li>只生成tcl文件：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-gen_tcl</span> <span class="pre">-s</span> <span class="pre">SRC</span></code></li>
<li>命令只创建$PROJ_ROOT/flow/dc/DC_TIMESTAMP目录生成tcl文件，不运行dc</li>
<li>生成出来的tcl output在$PROJ_ROOT/flow/dc/DC_TIMESTAMP下面</li>
</ul>
</li>
<li>指定特定的src目录，根据目录下的cfg与template生成tcl文件，并对相应RTL进行dc综合：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-gen_tcl</span> <span class="pre">-run</span> <span class="pre">-s</span> <span class="pre">SRC</span></code></li>
<li>-s为可选参数，指定一个包含cfg和template的src目录，默认为$PROJ_ROOT/flow/dc/src</li>
</ul>
</li>
<li>指定已存在的DC_TIMESTAMP目录，在该目录下利用已有的tcl文件对相应RTL进行dc综合：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-d</span> <span class="pre">DC_TIMESTAMP</span> <span class="pre">-run</span></code></li>
</ul>
</li>
<li>对相应RTL进行dc综合(topo模式)：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-d</span> <span class="pre">DC_TIMESTAMP</span> <span class="pre">-run</span> <span class="pre">-topo</span></code> 或 <code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-gen_tcl</span> <span class="pre">-run</span> <span class="pre">-topo</span></code></li>
</ul>
</li>
<li>对相应RTL进行dc综合，并自动生成文本格式的timing report：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-d</span> <span class="pre">DC_TIMESTAMP</span> <span class="pre">-run</span> <span class="pre">-tm</span></code> 或 <code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-gen_tcl</span> <span class="pre">-run</span> <span class="pre">-tm</span></code></li>
<li>文本格式的按timing violation分布区间的归纳统计报告：$PROJ_ROOT/flow/dc/DC_TIMESTAMP/reports/sum_tm</li>
</ul>
</li>
<li>调整timing report的startpoint与endpoint的hierarchy层数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-d</span> <span class="pre">DC_TIMESTAMP</span> <span class="pre">-run</span> <span class="pre">-tm</span> <span class="pre">-l</span> <span class="pre">2</span></code> 或 <code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-gen_tcl</span> <span class="pre">-run</span> <span class="pre">-tm</span> <span class="pre">-l</span> <span class="pre">2</span></code></li>
<li>-l level参数控制的是所需要统计的timing violation的startpoint与endpoint的hierarchy层数</li>
<li>默认level值为1</li>
</ul>
</li>
<li>对相应RTL进行dc综合之后自动进行综合前后的formality check：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-d</span> <span class="pre">DC_TIMESTAMP</span> <span class="pre">-run</span> <span class="pre">-fm</span></code> 或 <code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">dc</span> <span class="pre">-gen_tcl</span> <span class="pre">-run</span> <span class="pre">-fm</span></code></li>
<li>formality的output在$PROJ_ROOT/flow/dc/DC_TIMESTAMP/FM_TIMESTAMP下面</li>
</ul>
</li>
</ul>
<p>利用pj跑dc flow每次的结果都会被我们收集的数据库中，同样也有一个web页面可以展示之前每个人kick off每个dc的结果统计，关于该report平台、platform server以及平台数据库请参考 <a class="reference internal" href="backend.html#backend"><span class="std std-ref">backend构架介绍</span></a></p>
</div>
<div class="section" id="tm">
<h3>子命令tm<a class="headerlink" href="#tm" title="Permalink to this headline">¶</a></h3>
<p>tm是dc的附属子命令，目的是独立分析dc的timing report并生成文本格式的分布区间归纳统计报告：</p>
<ul class="simple">
<li>查看子命令tm的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">tm</span> <span class="pre">-h</span></code></li>
</ul>
</li>
<li>对相应的dc timing report进行分布区间归纳统计报告分析：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">tm</span> <span class="pre">-f</span> <span class="pre">TIMING_REPORT</span></code></li>
<li>生成的统计报告是TIMING REPORT同级的sum_tm</li>
<li>默认的level参数为1</li>
</ul>
</li>
<li>改变默认的level参数<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">tm</span> <span class="pre">-f</span> <span class="pre">TIMING_REPORT</span> <span class="pre">-l</span> <span class="pre">2</span></code></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="fm">
<h3>子命令fm<a class="headerlink" href="#fm" title="Permalink to this headline">¶</a></h3>
<p>fm是方便用户完成独立的formality比对的基础自动化流程：</p>
<p>src目录：</p>
<ul class="simple">
<li>src目录里面存放了一整套完整的配置可以用来跑某个模块的fm flow</li>
<li>-s参数可以用来指定特定的src目录，例如跑zszx的fm flow可以建一个zszx_src的目录，然后通过-s PATH/zszx_src指定；跑fdzx的fm flow可以建一个fdzx_src的目录，然后通过-s PATH/fdzx_src指定，PATH可以是相对路径或绝对路径</li>
<li>-s参数存在的目的是方便用户同时跑不同模块的fm flow，默认情况下src目录就是$PROJ_ROOT/flow/fm/src</li>
<li>src目录下面有fm.cfg文件、fm_template目录</li>
<li>pj会根据fm.cfg文件以及fm_template目录生成运行附属fm flow的tcl</li>
</ul>
<p>配置fm.cfg：</p>
<ul class="simple">
<li>打开$PROJ_ROOT/flow/fm/src/fm.cfg文件完成配置</li>
<li>配置格式与case.cfg格式相同，详见 <a class="reference internal" href="config.html#config"><span class="std std-ref">配置文件使用手册</span></a></li>
</ul>
<p>使用pj跑fm flow：</p>
<ul class="simple">
<li>提供ref与imp完成formality比对检查：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">fm</span> <span class="pre">-ref</span> <span class="pre">REF_FILE</span> <span class="pre">-imp</span> <span class="pre">IMP_FILE</span> <span class="pre">-s</span> <span class="pre">SRC</span></code></li>
<li>REF_FILE与IMP_FILE都可以是独立的.v文件或者filelist文件</li>
<li>-s为可选参数，用户可自行指定src目录，该目录下包含cfg文件和template，默认为$PROJ_ROOT/flow/fm/src目录</li>
<li>fm比对出来的output在$PROJ_ROOT/flow/fm/FM_TIMESTAMP下面</li>
</ul>
</li>
</ul>
<p>利用pj跑fm flow每次的结果也都会被我们收集的数据库中，请参考 <a class="reference internal" href="backend.html#backend"><span class="std std-ref">backend构架介绍</span></a></p>
</div>
<div class="section" id="icc">
<h3>子命令icc<a class="headerlink" href="#icc" title="Permalink to this headline">¶</a></h3>
<p>icc是方便用户完成物理设计的自动化流程：</p>
<ul class="simple">
<li>查看子命令icc的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">icc</span> <span class="pre">-h</span></code></li>
</ul>
</li>
</ul>
<p>src目录：</p>
<ul class="simple">
<li>src目录里面存放了一整套完整的配置可以用来跑某个模块的icc flow</li>
<li>-s参数可以用来指定特定的src目录，例如跑zszx的icc flow可以建一个zszx_src的目录，然后通过-s PATH/zszx_src指定；跑fdzx的icc flow可以建一个fdzx_src的目录，然后通过-s PATH/fdzx_src指定，PATH可以是相对路径或绝对路径</li>
<li>-s参数存在的目的是方便用户同时跑不同模块的icc flow，默认情况下src目录就是$PROJ_ROOT/flow/icc/src</li>
<li>src目录下面有icc.cfg文件、data目录、scripts目录</li>
<li>data目录用来存放icc flow过程中需要用到的data文件</li>
<li>scripts目录用来存放icc flow过程中需要用到的tcl文件</li>
<li>pj不会负责icc tcl的生成，只会控制运行scripts目录下相应阶段的tcl文件，将tcl开发与flow开发解耦合</li>
</ul>
<p>配置icc.cfg：</p>
<ul class="simple">
<li>打开$PROJ_ROOT/flow/icc/src/icc.cfg文件完成配置<ul>
<li>文件中icc_stage的key对应于pj icc命令中指定的stage，stage名可根据自己需要进行命名，value对应于运行该stage需要的tcl文件名</li>
<li>stage可以根据自己的需求进行拆分或合并，但是stage的顺序必须符合实际icc的执行顺序</li>
<li>文件中icc_string用于对icc的log进行检查，如果在某个stage的log中检测到不可忽略的Error，则不再运行后面的stage</li>
</ul>
</li>
</ul>
<p>使用pj跑icc flow：</p>
<ul class="simple">
<li>在指定的目录下运行icc的指定阶段：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">icc</span> <span class="pre">-d</span> <span class="pre">ICC_TIMESTAMP</span> <span class="pre">-stage</span> <span class="pre">init_design</span> <span class="pre">flat_dp</span> <span class="pre">place_opt</span></code></li>
<li>在ICC_TIMESTAMP目录下运行-stage后指定的icc的某一个或某几个阶段</li>
<li>icc运行的结果保存在目录ICC_TIMESTAMP下</li>
<li>检测的Error和Warning信息记录文件保存在ICC_TIMESTAMP/logs目录下</li>
<li>运行结束后会自动将运行结果备份到ICC_TIMESTAMP/BACKUP__STAGE__TIMESTAMP下</li>
</ul>
</li>
<li>在自动创建的新目录下运行icc的指定阶段：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">icc</span> <span class="pre">-stage</span> <span class="pre">init_design</span> <span class="pre">flat_dp</span> <span class="pre">-s</span> <span class="pre">SRC</span></code></li>
<li>自动创建$PROJ_ROOT/flow/icc/ICC_TIMESTAMP目录，在该目录下运行stage参数指定的icc的某些阶段</li>
<li>-s为可选参数，用来指定一个src目录，默认为$PROJ_ROOT/flow/icc/src目录</li>
<li>icc运行的结果保存在自动创建的目录$PROJ_ROOT/flow/icc/ICC_TIMESTAMP下</li>
</ul>
</li>
<li>在指定目录或新创建目录下运行完自指定阶段开始的所有icc的后续阶段：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">icc</span> <span class="pre">-d</span> <span class="pre">ICC_TIMESTAMP</span> <span class="pre">-s_stage</span> <span class="pre">flat_dp</span></code> 或 <code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">icc</span> <span class="pre">-s_stage</span> <span class="pre">flat_dp</span></code></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="cdc">
<h3>子命令cdc<a class="headerlink" href="#cdc" title="Permalink to this headline">¶</a></h3>
<p>cdc是方便用户完成跨时钟域检查的基础自动化流程：</p>
<ul class="simple">
<li>查看子命令icc的全部参数：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">cdc</span> <span class="pre">-h</span></code></li>
</ul>
</li>
</ul>
<p>src目录：</p>
<ul class="simple">
<li>src目录里面存放了一整套完整的配置可以用来跑某个模块的cdc flow</li>
<li>-s参数可以用来指定特定的src目录，例如跑zszx的cdc flow可以建一个zszx_src的目录，然后通过-s PATH/zszx_src指定；跑fdzx的cdc flow可以建一个fdzx_src的目录，然后通过-s PATH/fdzx_src指定，PATH可以是相对路径或绝对路径</li>
<li>-s参数存在的目的是方便用户同时跑不同模块的cdc flow，默认情况下src目录就是$PROJ_ROOT/flow/cdc/src</li>
<li>src目录下面有cdc.cfg文件、waiver.cfg文件、directives.tcl文件、template目录</li>
<li>directives.tcl文件是默认qs_file，可以指定，不是固定的</li>
<li>pj会根据cfg与template目录生成运行cdc的tcl</li>
</ul>
<p>配置cdc.cfg：</p>
<ul class="simple">
<li>打开$PROJ_ROOT/flow/cdc/src/cdc.cfg文件完成配置<ul>
<li>design_top与design_flist是必填项</li>
<li>qs_file可以指定，用来配置不同时钟域的clk</li>
<li>err_str是提供进行compile结果检查的标志字符</li>
</ul>
</li>
<li>配置格式与case.cfg格式相同，详见 <a class="reference internal" href="config.html#config"><span class="std std-ref">配置文件使用手册</span></a></li>
</ul>
<p>配置waiver.cfg：</p>
<ul class="simple">
<li>打开$PROJ_ROOT/flow/cdc/src/waiver.cfg文件完成配置<ul>
<li>section的名字为user name，表示用户check in的waiver，供cdc reviewer查看</li>
<li>sp|ep必须按照startpoint|endpoint的格式给出，否则会给出warning</li>
<li>type/startpoint/endpoint中均可以使用通配符*</li>
</ul>
</li>
</ul>
<p>使用pj跑cdc flow：</p>
<ul class="simple">
<li>根据配置的flist和design top运行cdc：<ul>
<li><code class="docutils literal"><span class="pre">$</span> <span class="pre">pj</span> <span class="pre">cdc</span> <span class="pre">-s</span> <span class="pre">SRC</span></code></li>
<li>-s可以指定一个包含运行cdc需要的cfg和tcl的目录，默认为$PROJ_ROOT/flow/cdc/src</li>
<li>cdc运行的结果保存在目录$PROJ_ROOT/flow/cdc/CDC_TIMESTAMP下</li>
<li>cdc运行完后对cdc_detail.rpt进行检查，将沒有waive掉的Violation写入$PROJ_ROOT/flow/cdc/CDC_TIMESTAMP/post_waiver.rpt文件</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id4">
<h2>平台目录结构<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>这里主要介绍和平台有关的目录结构</p>
<div class="section" id="proj-root-share-config">
<h3>PROJ_ROOT/share/config/<a class="headerlink" href="#proj-root-share-config" title="Permalink to this headline">¶</a></h3>
<p>proj.cfg所在目录</p>
</div>
<div class="section" id="proj-root-verification-module">
<h3>PROJ_ROOT/verification/MODULE<a class="headerlink" href="#proj-root-verification-module" title="Permalink to this headline">¶</a></h3>
<p>每个模块的主要工作目录</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>MODULE
├── c                         # 模块simulation所需要的c和asm文件
├── config                    # module.cfg, case.cfg, cov.filter, \*.el等文件
├── doc                       # NaturalDocs生成的doc
├── flist                     # rtl.flist, tb.flist
├── output                    # 所有仿真文件，临时文件，中间文件等不需要checkin的文件
│   ├── __c_lib__             # c和asm编译出来的库文件
│   ├── __cov__               # coverage相关文件
│   │   ├── cm                # coverage数据
│   │   └── merge             # coverage merge后的数据以及生成的report
│   ├── __simv__              # analysis+elaboration相关文件
│   │   ├── DEFAULT           # DEFAULT simv compilation相关文件，包括生成的simv
│   │   ├── simv1             # simv1 simv compilation相关文件，包括生成的simv
│   │   └── simv2
│   └── module_sanity_test    # module_sanity_test case相关文件
│       ├── DEFAULT__1        # 以simv__seed命名的目录，存放simulation相关文件
│       ├── DEFAULT__119974
│       ├── DEFAULT__205236
│       ├── DEFAULT__316245
│       ├── DEFAULT__370561
│       ├── DEFAULT__415104
│       ├── DEFAULT__563042
│       ├── DEFAULT__716947
│       ├── DEFAULT__753549
│       ├── simv1__91185
│       └── simv2__979315
├── reg                       # reg相关文件
├── tb                        # tb所有文件
├── upf                       # low power upf相关文件
└── vplan                     # vplan相关文件
</pre></div>
</div>
<p>每个新模块在已经有c与tb目录的情况下，只需要完成 <strong>config目录下的module.cfg和case.cfg</strong> 还有 <strong>flist目录下的rtl.flist与tb.flist</strong> 就可以调用pj了</p>
</div>
</div>
<div class="section" id="id5">
<h2>开发阶段说明<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>pj目前发布的是一个稳定的版本，日后不会有太大的功能改动，欢迎大家试用，如有任何问题及建议，请联系平台组 <strong>yigy&#64;cpu.com.cn</strong></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="backend.html" title="backend构架介绍"
             >next</a> |</li>
        <li class="right" >
          <a href="config.html" title="配置文件使用手册"
             >previous</a> |</li>
<li><a href="http://172.51.13.205:8000">HOME</a> &raquo;</li>

        <li class="nav-item nav-item-0"><a href="index.html">Verification Platform 1.0 documentation</a> &#187;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Guanyu Yi.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>