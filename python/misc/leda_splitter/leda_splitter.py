#! /usr/bin/env python3
### used to split leda logs according to csv format waiver file

import argparse
import os
import collections
import re
import copy
import texttable

class REOpter(object):
    def __init__(self, re_str):
        self.re_str = re_str
    def match(self, re_rs):
        self.re_result = re.match(re_rs, self.re_str)
        return bool(self.re_result)
    def search(self, re_rs):
        self.re_result = re.search(re_rs, self.re_str)
        return bool(self.re_result)
    def group(self, i):
        return self.re_result.group(i)

def gen_log_file(log_file, log_dic):
    user_table = texttable.Texttable()
    user_table.add_rows([['file generated by', log_dic['info'].pop('user')],
                         ['date', log_dic['info'].pop('date')]], header=False)

    sum_rows = [['including {0}'.format(cc), cc_v]
                for cc, cc_v in log_dic['info'].items() if cc_v != 0]
    rule_rows = [[cc_dic['num'], cc, cc_dic['desc']]
                 for cc, cc_dic in log_dic['rule'].items()
                 if cc_dic['num'] != 0]

    sum_table = texttable.Texttable()
    sum_table.add_rows([['rules violated', len(rule_rows)],
                        ['total violations', sum(log_dic['info'].values())]]+
                       sum_rows, header=False)

    rule_table = texttable.Texttable()
    rule_table.set_cols_width([10,20,60])
    rule_table.add_rows([['v No.', 'v rule', 'rule desc']]+rule_rows)

    file_rows = [[cc_dic['num'], cc]
                 for cc, cc_dic in log_dic['file'].items()
                 if cc_dic['num'] != 0]
    file_table = texttable.Texttable()
    file_table.add_rows([['v No.', 'file']]+file_rows)

    with open(log_file, 'w') as f:
        f.write(user_table.draw()+os.linesep+os.linesep)
        f.write(sum_table.draw()+os.linesep+os.linesep)
        f.write(rule_table.draw()+os.linesep+os.linesep)
        f.write(file_table.draw()+os.linesep+os.linesep)
        f.write(os.linesep.join(log_dic['v']))
    print('generating leda log file {0} done'.format(log_file))
    
def gen_args_top():
    parser = argparse.ArgumentParser()
    h_str = ("input leda log file")
    parser.add_argument('-lf', dest='log_file', required=True, help=h_str)
    h_str = ("input waiver csv file")
    parser.add_argument('-wf', dest='waiver_file', required=True, help=h_str)
    return parser.parse_args()

args = gen_args_top()
if not os.path.isfile(args.log_file):
    os.sys.exit("signal file {0} is NA".format(args.log_file))
if not os.path.isfile(args.waiver_file):
    os.sys.exit("duplicated port signal file {0} is NA".format(
        args.waiver_file))

w_lst_lst = []
with open(args.waiver_file) as f:
    for line in f:
        if '//' in line or '#' in line:
            line = re.sub(r'(//|#).*$', '', line)
        line = line.strip()
        if not line:
            continue
        w_lst_lst.append([cc.strip() for cc in line.split(',') if cc.strip()])

with open(args.log_file, errors='replace') as f:
    l_lst = re.split(r'{0}\s+\d+:.*?{0}\s+\^+{0}'.format(os.linesep),
                     f.read(), flags=re.DOTALL)

info_dic = collections.OrderedDict()
rule_dic = collections.OrderedDict()
file_dic = collections.OrderedDict()
v_lst = []

for head_line in l_lst[0].split(os.linesep):
    if not head_line.startswith('--'):
        continue
    hl = head_line[2:].strip()
    m = REOpter(hl)
    if m.match(r'File generated by\s*:\s+(\w+)'):
        info_dic['user'] = m.group(1)
    elif m.match(r'Date\s*:\s+(.*)'):
        info_dic['date'] = m.group(1)
    elif m.match(r'Including\s+(\w+)\s*:\s+\d+'):
        info_dic[m.group(1)] = 0
    elif m.match(r'\d+\s+x\s+(\w+):\s+(.*)'):
        rule_dic[m.group(1)] = {'num': 0, 'desc': m.group(2)}
    elif m.match(r'\d+\s+in\s+(.*)'):
        file_dic[m.group(1)] = {'num': 0}

winfo_dic = copy.deepcopy(info_dic)
wrule_dic = copy.deepcopy(rule_dic)
wfile_dic = copy.deepcopy(file_dic)
wv_lst = []

for v_item in l_lst[1:]:
    line = v_item.split(os.linesep)[0]
    m = REOpter(line)
    if m.match(r'(.*?):(\d+):.*?\[(\w+)\]\s+(\w+):'):
        line_lst = [m.group(1), m.group(2), m.group(3), m.group(4)]
    else:
        os.sys.exit("line {0} is not obey leda report rules".format(line))
    for w_lst in w_lst_lst:
        hit_flg = (True if line_lst == w_lst or
                   w_lst[1] == 'all' and line_lst[0] == w_lst[0] and
                   line_lst[2] == w_lst[2] and line_lst[3] == w_lst[3] else
                   False)
        if hit_flg:
            winfo_dic[line_lst[2]] += 1
            wrule_dic[line_lst[3]]['num'] += 1
            wfile_dic[os.path.basename(line_lst[0])]['num'] += 1
            wv_lst.append(line)
            break;
    else:
        info_dic[line_lst[2]] += 1
        rule_dic[line_lst[3]]['num'] += 1
        file_dic[os.path.basename(line_lst[0])]['num'] += 1
        v_lst.append(line)

log_file_base, log_file_ext = os.path.splitext(args.log_file)
nwaive_file = log_file_base+'_nwaive'+log_file_ext
waive_file = log_file_base+'_waive'+log_file_ext

gen_log_file(nwaive_file, {'info': info_dic, 'rule': rule_dic,
                           'file': file_dic, 'v': v_lst})
gen_log_file(waive_file, {'info': winfo_dic, 'rule': wrule_dic,
                           'file': wfile_dic, 'v': wv_lst})
